name: E2E Tests

permissions:
  contents: read
  actions: write # Needed for uploading artifacts

on:
  pull_request: # Runs BEFORE merge during PR review
    branches:
      - main # Feature branches -> main
      - release # main -> release (production)
    paths:
      - 'apps/**'
      - 'packages/**'
      - '!**/*.md'
      - '.github/workflows/e2e-tests.yml'
  push: # Also runs AFTER merge to main/release
    branches:
      - main
      - release
  workflow_dispatch: # Allow manual triggering

jobs:
  e2e-tests:
    name: E2E Tests - ${{ matrix.project }}
    runs-on: ubuntu-latest-custom
    timeout-minutes: 20

    strategy:
      fail-fast: false
      matrix:
        project: [chromium, firefox, webkit]

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
            apps/*/node_modules
            packages/*/node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Cache Next.js build
        uses: actions/cache@v4
        with:
          path: |
            apps/app/.next/cache
          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/bun.lock') }}-${{ hashFiles('apps/app/**/*.js', 'apps/app/**/*.jsx', 'apps/app/**/*.ts', 'apps/app/**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('**/bun.lock') }}-
            ${{ runner.os }}-nextjs-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Setup database
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        run: |
          cd packages/db
          bunx prisma migrate deploy
          bunx prisma db seed || true # Allow seed to fail

      - name: Generate Prisma Client
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
        run: |
          cd packages/db
          bunx prisma generate

      - name: Get Playwright version
        id: playwright-version
        run: |
          cd apps/app
          PLAYWRIGHT_VERSION=$(bunx playwright --version | sed 's/Version //')
          echo "Playwright version: $PLAYWRIGHT_VERSION"
          echo "version=$PLAYWRIGHT_VERSION" >> $GITHUB_OUTPUT
          echo "Cache key will be: ${{ runner.os }}-playwright-${PLAYWRIGHT_VERSION}-${{ matrix.project }}"

      - name: Cache Playwright browsers
        id: playwright-cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}-${{ matrix.project }}
          restore-keys: |
            ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}-

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: |
          cd apps/app
          echo "Cache miss - installing Playwright browsers"
          bunx playwright install --with-deps ${{ matrix.project }}

      - name: Install system dependencies only
        if: steps.playwright-cache.outputs.cache-hit == 'true'
        run: |
          cd apps/app
          echo "Cache hit - installing system dependencies only"
          bunx playwright install-deps ${{ matrix.project }}

      - name: Build app
        run: |
          cd apps/app
          export E2E_TEST_MODE=true
          bunx next build
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          NEXTAUTH_URL: http://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-ci
          AUTH_SECRET: test-secret-for-ci
          BETTER_AUTH_URL: http://localhost:3000
          E2E_TEST_MODE: true
          # Additional env vars that might be needed
          UPSTASH_REDIS_REST_URL: https://dummy.upstash.io
          UPSTASH_REDIS_REST_TOKEN: dummy-token
          RESEND_API_KEY: dummy-resend-key
          TRIGGER_SECRET_KEY: dummy-trigger-key
          STRIPE_SECRET_KEY: sk_test_dummy_key_for_ci_builds
          STRIPE_WEBHOOK_SECRET: whsec_test_dummy_webhook_secret

      - name: Start server
        run: |
          cd apps/app
          # Start server with explicit port and capture output
          PORT=3000 bun run start > server.log 2>&1 &
          SERVER_PID=$!

          # Wait for server to be ready
          echo "Waiting for server to start (PID: $SERVER_PID)..."
          for i in {1..30}; do
            # Show server logs for debugging
            if [ -f server.log ]; then
              echo "=== Server logs (last 20 lines) ==="
              tail -20 server.log
              echo "=== End server logs ==="
            fi
            
            # Check if server is responding
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>&1 | grep -q "200\|302\|303\|307"; then
              echo "Server is responding! Testing health endpoint..."
              
              # Test health endpoint first
              HEALTH_RESPONSE=$(curl -s http://localhost:3000/api/health 2>&1)
              echo "Health endpoint response: $HEALTH_RESPONSE"
              
              # Test DB endpoint
              echo "Testing database connection..."
              DB_RESPONSE=$(curl -s http://localhost:3000/api/auth/test-db 2>&1)
              echo "DB test response: $DB_RESPONSE"
              
              # Test auth endpoint
              echo "Testing auth endpoint..."
              RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:3000/api/auth/test-login -X POST -H "Content-Type: application/json" -d '{"email":"test@example.com"}' --max-time 10 2>&1)
              HTTP_CODE=$(echo "$RESPONSE" | tail -1)
              BODY=$(echo "$RESPONSE" | head -n -1)
              echo "Auth endpoint response code: $HTTP_CODE"
              echo "Auth endpoint response body: $BODY"
              
              if [ "$HTTP_CODE" = "403" ] || [ "$HTTP_CODE" = "400" ] || [ "$HTTP_CODE" = "500" ] || [ "$HTTP_CODE" = "200" ]; then
                echo "Auth endpoint is responding!"
                break
              elif [ "$HTTP_CODE" = "000" ]; then
                echo "Auth endpoint timed out after 10 seconds"
              fi
            else
              echo "Server not ready yet... (attempt $i/30)"
            fi
            
            # Check if process is still alive
            if ! kill -0 $SERVER_PID 2>/dev/null; then
              echo "ERROR: Server process died! Last logs:"
              tail -50 server.log
              exit 1
            fi
            
            sleep 2
          done

          # Final check
          if ! curl -s http://localhost:3000 > /dev/null 2>&1; then
            echo "ERROR: Server never became ready! Final logs:"
            tail -100 server.log
            exit 1
          fi

          echo "Server successfully started and ready for E2E tests!"
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          NEXTAUTH_URL: http://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-ci
          AUTH_SECRET: test-secret-for-ci
          BETTER_AUTH_URL: http://localhost:3000
          PLAYWRIGHT_BASE_URL: http://localhost:3000
          E2E_TEST_MODE: true
          E2E_USE_REAL_AUTH: false
          CI: true
          # Additional env vars that might be needed
          UPSTASH_REDIS_REST_URL: https://dummy.upstash.io
          UPSTASH_REDIS_REST_TOKEN: dummy-token
          RESEND_API_KEY: dummy-resend-key
          TRIGGER_SECRET_KEY: dummy-trigger-key
          STRIPE_SECRET_KEY: sk_test_dummy_key_for_ci_builds
          STRIPE_WEBHOOK_SECRET: whsec_test_dummy_webhook_secret

      - name: Run E2E tests
        run: |
          cd apps/app
          echo "Starting E2E tests for ${{ matrix.project }} with 2 workers..."
          bunx playwright test --project=${{ matrix.project }} --reporter=list
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          NEXTAUTH_URL: http://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-ci
          AUTH_SECRET: test-secret-for-ci
          BETTER_AUTH_URL: http://localhost:3000
          PLAYWRIGHT_BASE_URL: http://localhost:3000
          E2E_TEST_MODE: true
          E2E_USE_REAL_AUTH: false
          CI: true
          # Additional env vars that might be needed
          UPSTASH_REDIS_REST_URL: https://dummy.upstash.io
          UPSTASH_REDIS_REST_TOKEN: dummy-token
          RESEND_API_KEY: dummy-resend-key
          TRIGGER_SECRET_KEY: dummy-trigger-key
          STRIPE_SECRET_KEY: sk_test_dummy_key_for_ci_builds
          STRIPE_WEBHOOK_SECRET: whsec_test_dummy_webhook_secret

      - name: Show server logs on failure
        if: failure()
        run: |
          echo "=== Server logs after test failure ==="
          if [ -f apps/app/server.log ]; then
            tail -200 apps/app/server.log
          else
            echo "No server.log file found"
          fi
          echo "=== End server logs ==="

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-results-${{ matrix.project }}
          path: apps/app/test-results/
          retention-days: 7

      - name: Upload test artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-artifacts-${{ matrix.project }}
          path: |
            apps/app/playwright-report/
            apps/app/test-results/**/*.png
            apps/app/test-results/**/*.webm
          retention-days: 7

      - name: Post test results to PR
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Read test results if available
            let testSummary = '## ❌ E2E Tests Failed\n\n';
            testSummary += `**Project:** ${{ matrix.project }}\n\n`;

            // Add server logs snippet
            const serverLogPath = 'apps/app/server.log';
            if (fs.existsSync(serverLogPath)) {
              const logs = fs.readFileSync(serverLogPath, 'utf8');
              const lines = logs.split('\n');
              const relevantLogs = lines.slice(-50).join('\n');
              
              // Extract key errors
              const errors = lines.filter(line => 
                line.includes('Error:') || 
                line.includes('TEST-LOGIN') ||
                line.includes('MIDDLEWARE') ||
                line.includes('SUBSCRIPTION')
              ).slice(-10);
              
              if (errors.length > 0) {
                testSummary += '### Key Errors:\n```\n' + errors.join('\n') + '\n```\n\n';
              }
              
              testSummary += '<details>\n<summary>📋 Server Logs (last 50 lines)</summary>\n\n```\n';
              testSummary += relevantLogs;
              testSummary += '\n```\n</details>\n\n';
            }

            // Add test output summary
            testSummary += `### Test Results\n`;
            testSummary += `- **Status**: Failed\n`;
            testSummary += `- **Browser**: ${{ matrix.project }}\n`;
            testSummary += `- **Artifacts**: Check the [Actions tab](${context.payload.pull_request.html_url.replace('/pull/', '/actions/runs/')}) for screenshots and videos\n\n`;

            testSummary += `💡 **Tip**: Download the test artifacts from the workflow run to see screenshots and videos of the failures.\n`;

            // Create or update comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('E2E Tests Failed') &&
              comment.body.includes(`Project:** ${{ matrix.project }}`)
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: testSummary
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: testSummary
              });
            }

      - name: Post success comment to PR
        if: success() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            // Check if there was a previous failure comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('E2E Tests Failed') &&
              comment.body.includes(`Project:** ${{ matrix.project }}`)
            );

            if (botComment) {
              // Update the comment to show success
              const successMessage = `## ✅ E2E Tests Passed\n\n**Project:** ${{ matrix.project }}\n\nAll E2E tests are now passing! 🎉`;
              
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: successMessage
              });
            }

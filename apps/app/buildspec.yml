version: 0.2

phases:
  pre_build:
    commands:
      - echo "Logging in to Amazon ECR..."
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
      - REPOSITORY_URI=$ECR_REPOSITORY_URI
      - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - IMAGE_TAG=${COMMIT_HASH:=latest}
      - echo "Installing dependencies..."
      - curl -fsSL https://bun.sh/install | bash

  build:
    commands:
      # Environment setup
      - export PATH="/root/.bun/bin:$PATH"
      - export PGSSLMODE=require
      - export NODE_ENV=production
      - export NEXT_TELEMETRY_DISABLED=1
      - export UV_THREADPOOL_SIZE=36
      - export NODE_OPTIONS="--max-old-space-size=65536"

      # Navigate to app directory
      - cd apps/$APP_NAME

      # Install dependencies
      - echo "Installing dependencies..."
      - SKIP_ENV_VALIDATION=true bun install --frozen-lockfile --concurrent 36 || SKIP_ENV_VALIDATION=true bun install --concurrent 36
      - cd ../../

      # Generate Prisma client
      - echo "Generating Prisma client..."
      - cd packages/db && bun x prisma generate && cd ../../

      # Validate environment variables
      - echo "Validating environment variables..."
      - '[ -n "$NEXT_PUBLIC_PORTAL_URL" ] || { echo "‚ùå NEXT_PUBLIC_PORTAL_URL is not set"; exit 1; }'
      - '[ -n "$STATIC_ASSETS_BUCKET" ] || { echo "‚ùå STATIC_ASSETS_BUCKET is not set"; exit 1; }'

      # Type check
      - echo "Type checking..."
      - cd apps/$APP_NAME && bun run typecheck && cd ../../

      # Clear Next.js cache to prevent stale server actions
      - echo "Clearing Next.js cache to prevent stale builds..."
      - cd apps/$APP_NAME
      - rm -rf .next/cache/

      # Build Next.js app
      - echo "Building Next.js application..."
      - NODE_TLS_REJECT_UNAUTHORIZED=0 bun run build

      # Upload Next.js chunks and CSS to S3 for direct access
      - echo "Uploading Next.js static assets to S3..."
      - |
        if [ -d ".next/static" ]; then
          echo "üì¶ Uploading .next/static/ files to S3..."
          aws s3 sync .next/static/ s3://$STATIC_ASSETS_BUCKET/app/_next/static/ \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "*.map"
          echo "‚úÖ Uploaded Next.js static assets to S3"
          
          # Verify upload completed successfully
          echo "üîç Verifying S3 upload completed..."
          CHUNK_COUNT=$(find .next/static -name "*.js" | wc -l)
          S3_COUNT=$(aws s3 ls s3://$STATIC_ASSETS_BUCKET/app/_next/static/ --recursive | grep "\.js$" | wc -l)
          echo "Local chunks: $CHUNK_COUNT, S3 chunks: $S3_COUNT"
          
          if [ "$S3_COUNT" -ge "$CHUNK_COUNT" ]; then
            echo "‚úÖ S3 upload verification successful"
          else
            echo "‚ö†Ô∏è S3 upload may be incomplete, but continuing..."
          fi
          
          # CloudFront invalidation no longer needed - using direct S3 access
          echo "‚úÖ Static assets uploaded to S3 for direct access"
        else
          echo "‚ö†Ô∏è No .next/static directory found"
        fi

      # Upload public assets to S3 for direct serving
      - |
        if [ -d "public" ]; then
          echo "üì¶ Uploading public/ files to S3..."
          aws s3 sync public/ s3://$STATIC_ASSETS_BUCKET/app/ \
            --cache-control "public, max-age=86400" \
            --exclude "*.map" \
            --exclude "_next/*"
          echo "‚úÖ Uploaded public assets to S3"
        else
          echo "‚ö†Ô∏è No public directory found"
        fi

      # Prepare standalone build for container
      - echo "Preparing standalone build..."
      - echo "DEBUG - Checking what Next.js built..."
      - ls -la .next/
      - ls -la .next/standalone/ || echo "No standalone directory"
      - echo "DEBUG - Checking standalone structure..."
      - find .next/standalone -name "server.js" -ls || echo "No server.js found"
      - ls -la .next/standalone/apps/$APP_NAME/ || echo "No app directory"
      - echo "DEBUG - Checking app's own .next build structure..."
      - ls -la .next/server/ || echo "No .next/server directory"
      - ls -la .next/standalone/ || echo "No .next/standalone directory"
      - echo "DEBUG - Checking for server.js in various locations..."
      - test -f .next/standalone/server.js && echo "‚úÖ Standalone server.js exists" || echo "‚ùå No standalone server.js"
      - find .next -name "server.js" | head -5 || echo "No server.js found anywhere"

      # Create container build directory
      - mkdir -p container-build

      # Use the standalone build properly: copy from .next/standalone + app's own build
      - echo "DEBUG - Building container from standalone + app build..."

      # Copy the COMPLETE standalone build first (includes server actions)
      - echo "Copying complete standalone build..."
      - cp -r .next/standalone/* container-build/ || echo "Standalone copy failed"

      # Then overlay the app's own .next directory (preserves server actions mapping)
      - echo "Overlaying app's own .next build..."
      - cp -r .next container-build/ || echo "App .next overlay failed"

      # CRITICAL: Verify container has all necessary files
      - echo "üîç Verifying container build completeness..."
      - ls -la container-build/.next/static/ || echo "No static directory in container"
      - ls -la container-build/.next/server/ || echo "No server directory in container"
      - CONTAINER_CHUNKS=$(find container-build/.next/static -name "*.js" 2>/dev/null | wc -l)
      - CONTAINER_SERVER_FILES=$(find container-build/.next/server -name "*.js" 2>/dev/null | wc -l)
      - 'echo "Container chunks: $CONTAINER_CHUNKS, Server files: $CONTAINER_SERVER_FILES"'

      - 'if [ "$CONTAINER_CHUNKS" -eq 0 ]; then echo "‚ùå ERROR: No static chunks found in container build!" && exit 1; fi'
      - 'if [ "$CONTAINER_SERVER_FILES" -eq 0 ]; then echo "‚ùå ERROR: No server files found in container build!" && exit 1; fi'
      - echo "‚úÖ Container build verification passed"

      # Copy or create server.js for standalone
      - |
        if [ -f ".next/standalone/apps/$APP_NAME/server.js" ]; then
          echo "Using app-specific standalone server.js..."
          cp .next/standalone/apps/$APP_NAME/server.js container-build/
        elif [ -f ".next/standalone/server.js" ]; then
          echo "Using global standalone server.js..."
          cp .next/standalone/server.js container-build/
        else
          echo "Creating minimal standalone server.js..."
          cat > container-build/server.js << 'EOF'
        const { createServer } = require('http')
        const next = require('next')

        const dev = false
        const hostname = process.env.HOSTNAME || '0.0.0.0'
        const port = process.env.PORT || 3000

        // Use the current directory as the Next.js app
        const app = next({ dev, hostname, port, dir: __dirname })
        const handle = app.getRequestHandler()

        app.prepare().then(() => {
          createServer(async (req, res) => {
            await handle(req, res)
          }).listen(port, hostname, () => {
            console.log(`> Ready on http://${hostname}:${port}`)
          })
        })
        EOF
        fi

      # Verify the app-specific standalone build
      - echo "DEBUG - Verifying app-specific standalone build..."
      - ls -la container-build/
      - test -f container-build/server.js && echo "‚úÖ App server.js exists" || echo "‚ùå App server.js missing"
      - test -d container-build/.next && echo "‚úÖ .next directory exists" || echo "‚ùå .next directory missing"
      - test -d container-build/node_modules && echo "‚úÖ node_modules exists" || echo "‚ùå node_modules missing"

      # Add Dockerfile to the standalone build
      - cp Dockerfile container-build/ || echo "No Dockerfile"

      # Ensure Prisma client is available (override standalone if needed)
      - echo "Ensuring Prisma client is available..."
      - mkdir -p container-build/node_modules/.prisma container-build/node_modules/@prisma
      - |
        if [ -d "../../node_modules/.prisma/client" ]; then
          echo "Copying Prisma client from monorepo root..."
          cp -r ../../node_modules/.prisma/client container-build/node_modules/.prisma/
        elif [ -d "node_modules/.prisma/client" ]; then
          echo "Copying Prisma client from app directory..."
          cp -r node_modules/.prisma/client container-build/node_modules/.prisma/
        else
          echo "Warning: No Prisma client found"
        fi
      - |
        if [ -d "../../node_modules/@prisma/client" ]; then
          echo "Copying @prisma/client from monorepo root..."
          cp -r "../../node_modules/@prisma/client" "container-build/node_modules/@prisma/"
        elif [ -d "node_modules/@prisma/client" ]; then
          echo "Copying @prisma/client from app directory..."
          cp -r "node_modules/@prisma/client" "container-build/node_modules/@prisma/"
        else
          echo "Warning: No @prisma/client found"
        fi

      # Debug: Verify container build contents
      - echo "DEBUG - Verifying app-specific container build..."
      - ls -la container-build/
      - ls -la container-build/.next/ || echo "‚ùå .next directory not found"
      - ls -la container-build/node_modules/next/ || echo "‚ùå Next.js module not found"
      - ls -la container-build/node_modules/.prisma/ || echo "‚ùå Prisma client not found"
      - test -f container-build/server.js && echo "‚úÖ App-specific server.js found" || echo "‚ùå App-specific server.js not found"
      - head -10 container-build/server.js || echo "‚ùå Cannot read server.js"

      # Ensure all S3 operations are complete before building container
      - echo "‚è≥ Waiting for S3 operations to fully complete..."
      - sleep 5

      # Final verification before Docker build
      - echo "üîç Final pre-build verification..."
      - aws s3 ls s3://$STATIC_ASSETS_BUCKET/app/_next/static/ --recursive | tail -5 || echo "S3 listing failed"

      # Build Docker image (static assets served directly from S3)
      - echo "üê≥ Building Docker image..."
      - docker build --build-arg BUILDKIT_INLINE_CACHE=1 -f container-build/Dockerfile -t $ECR_REPOSITORY_URI:$IMAGE_TAG container-build/
      - docker tag $ECR_REPOSITORY_URI:$IMAGE_TAG $ECR_REPOSITORY_URI:latest

      # Test container starts correctly (catch issues early)
      - echo "üß™ Testing container startup..."
      - timeout 30s docker run --rm -d -p 3001:3000 $ECR_REPOSITORY_URI:$IMAGE_TAG && echo "‚úÖ Container startup test passed" || echo "‚ö†Ô∏è Container startup test failed (non-critical)"

  post_build:
    commands:
      - echo "Pushing images to ECR..."
      - docker push $ECR_REPOSITORY_URI:$IMAGE_TAG
      - docker push $ECR_REPOSITORY_URI:latest
      - echo "Updating ECS service..."
      - aws ecs update-service --cluster $ECS_CLUSTER_NAME --service $ECS_SERVICE_NAME --force-new-deployment
      - 'printf "[{\"name\":\"%s-container\",\"imageUri\":\"%s\"}]" $APP_NAME $ECR_REPOSITORY_URI:$IMAGE_TAG > imagedefinitions.json'

cache:
  paths:
    - 'node_modules/**/*'
    - 'packages/db/node_modules/**/*'
    - '/root/.bun/install/cache/**/*'
    # Exclude .next/cache to prevent stale server action mappings
    # - '.next/cache/**/*'
    - 'bun.lock'

artifacts:
  files:
    - imagedefinitions.json
  name: ${APP_NAME}-build

'use server'

// Import the Prisma client directly
import { db } from '@comp/db';
// Import data from @comp/data - this assumes your package exports these named constants
import {
    controls as allControlsData // rename
    ,
    frameworks as allFrameworksData, // Assuming this specific set is what's needed, or a more generic allRequirements structure
    policies as allPoliciesData, // rename
    tasks as allTasksData, // rename to avoid conflict with a potential frameworks variable
    soc2Requirements,
    trainingVideos
} from '@comp/data';
import { revalidatePath } from 'next/cache';

const revalidatePaths = [
    '/frameworks',
    '/policies',
    '/tasks',
    '/controls'
  ]

export async function resetDataAction(): Promise<{ success: boolean; message?: string; error?: string }> {
  try {
    await db.$transaction(async (tx) => {
      console.log('Starting data reset transaction...');

      // --- DELETION PHASE ---
      console.log('Deleting existing Framework Editor data...');
      // Order: M-N link tables implicitly handled by Prisma if relations defined with onDelete?
      // Otherwise, explicit deletion of dependent entities or join table records might be needed if not cascaded.
      // For now, deleting main entities in an order that respects explicit foreign keys.
      await tx.frameworkEditorControlTemplate.deleteMany({});
      await tx.frameworkEditorRequirement.deleteMany({}); 
      await tx.frameworkEditorPolicyTemplate.deleteMany({});
      await tx.frameworkEditorTaskTemplate.deleteMany({});
      await tx.frameworkEditorFramework.deleteMany({}); 
      await tx.frameworkEditorVideo.deleteMany({});
      console.log('Existing Framework Editor data deleted.');

      // --- CREATION PHASE ---
      // Store newly generated DB IDs, keyed by their original unique identifier from data files
      // (e.g., original ID, slug, or a combination that makes them unique in the source data)
      const createdVideoDbIds: { [originalDataId: string]: string } = {};
      const createdFrameworkDbIds: { [originalDataKey: string]: string } = {};
      // Key policies by their original metadata.id from the data files
      const createdPolicyDbIds: { [originalMetadataId: string]: string } = {}; 
      const createdTaskDbIds: { [originalDataId: string]: string } = {};

      console.log('Creating FrameworkEditorVideos...');
      for (const videoData of trainingVideos) {
        const newVideo = await tx.frameworkEditorVideo.create({
          data: {
            // id is auto-generated by DB
            title: videoData.title,
            description: videoData.description,
            youtubeId: videoData.youtubeId,
            url: videoData.url,
          },
        });
        createdVideoDbIds[videoData.id] = newVideo.id; // Key by original data ID
      }
      console.log(`${trainingVideos.length} FrameworkEditorVideos created.`);

      console.log('Creating FrameworkEditorFrameworks...');
      for (const frameworkKey in allFrameworksData) {
        const frameworkData = allFrameworksData[frameworkKey as keyof typeof allFrameworksData];
        const newFramework = await tx.frameworkEditorFramework.create({
          data: {
            // id is auto-generated by DB, but Prisma needs a value if not default CUID/UUID.
            // If your schema for Framework is `@id @default(dbgenerated("generate_prefixed_cuid(...)"))` this is fine.
            // However, if it's just `@id` and you rely on this key being the ID, you MUST provide it.
            // For now, assuming the schema uses `frameworkKey` as the intended ID and it's unique.
            id: frameworkKey, // Example: "soc2" - this needs to match schema intent
            name: frameworkData.name,
            version: frameworkData.version,
            description: frameworkData.description,
          },
        });
        createdFrameworkDbIds[frameworkKey] = newFramework.id;
      }
      console.log(`${Object.keys(allFrameworksData).length} FrameworkEditorFrameworks created.`);

      console.log('Creating FrameworkEditorRequirements (for SOC2 initially)...');
      let requirementsCreatedCount = 0;
      const soc2FrameworkDbId = createdFrameworkDbIds['soc2'];
      if (soc2FrameworkDbId) {
        for (const reqKey in soc2Requirements) {
            const reqData = soc2Requirements[reqKey as keyof typeof soc2Requirements];
            await tx.frameworkEditorRequirement.create({
                data: {
                    // id is auto-generated
                    frameworkId: soc2FrameworkDbId,
                    name: reqKey, 
                    description: reqData.description,
                },
            });
            requirementsCreatedCount++;
        }
      }
      console.log(`${requirementsCreatedCount} FrameworkEditorRequirements created for SOC2.`);

      console.log('Creating FrameworkEditorPolicyTemplates...');
      for (const policyKey in allPoliciesData) {
        const policyData = allPoliciesData[policyKey as keyof typeof allPoliciesData];
        const newPolicy = await tx.frameworkEditorPolicyTemplate.create({
          data: {
            // id is auto-generated by DB
            name: policyData.metadata.name,
            description: policyData.metadata.description,
            frequency: policyData.metadata.frequency, 
            department: policyData.metadata.department,
            content: policyData.content as any, 
          },
        });
        // Key by original metadata.id from the data file (e.g., "vendor_risk_management")
        createdPolicyDbIds[policyData.metadata.id] = newPolicy.id; 
      }
      console.log(`${Object.keys(allPoliciesData).length} FrameworkEditorPolicyTemplates created.`);
      
      console.log('Creating FrameworkEditorTaskTemplates...');
      for (const taskKey in allTasksData) {
        const taskData = allTasksData[taskKey as keyof typeof allTasksData];
        const newTask = await tx.frameworkEditorTaskTemplate.create({
          data: {
            // id is auto-generated by DB
            name: taskData.name, // Name should be unique if used as a key for controls later
            description: taskData.description,
            frequency: taskData.frequency,
            department: taskData.department,
          },
        });
        createdTaskDbIds[taskData.id] = newTask.id; // Key by original data ID (ensure this taskData.id is unique among tasks)
      }
      console.log(`${Object.keys(allTasksData).length} FrameworkEditorTaskTemplates created.`);

      console.log('Creating FrameworkEditorControlTemplates and linking relations...');
      for (const controlData of allControlsData) {
        const policyConnects = controlData.mappedArtifacts
          .map(artifact => {
            // artifact.policyId is the key in allPoliciesData (e.g., "vendor_risk_management_policy")
            const originalPolicyFileObject = allPoliciesData[artifact.policyId];
            if (!originalPolicyFileObject) {
              console.warn(`Could not find policy data for key: ${artifact.policyId} when mapping control ${controlData.name}`);
              return null;
            }
            const originalPolicyMetadataId = originalPolicyFileObject.metadata.id; // e.g. "vendor_risk_management"
            const newPolicyDbId = createdPolicyDbIds[originalPolicyMetadataId];
            if (!newPolicyDbId) {
              console.warn(`Could not find new DB ID for policy with original metadata.id: ${originalPolicyMetadataId} (from key ${artifact.policyId}) for control ${controlData.name}`);
              return null;
            }
            return { id: newPolicyDbId };
          })
          .filter(Boolean) as { id: string }[];

        const taskConnects = controlData.mappedTasks
          .map(task => {
            const originalTaskFileObject = allTasksData[task.taskId]; // task.taskId is the key in allTasksData
            if (!originalTaskFileObject) {
              console.warn(`Could not find task data for key: ${task.taskId} when mapping control ${controlData.name}`);
              return null;
            }
            const originalTaskDataId = originalTaskFileObject.id; // e.g. "access_control_records_task_id"
            const newTaskDbId = createdTaskDbIds[originalTaskDataId];
             if (!newTaskDbId) {
              console.warn(`Could not find new DB ID for task with original data id: ${originalTaskDataId} (from key ${task.taskId}) for control ${controlData.name}`);
              return null;
            }
            return { id: newTaskDbId };
          })
          .filter(Boolean) as { id: string }[];

        await tx.frameworkEditorControlTemplate.create({
          data: {
            // id is auto-generated by DB
            name: controlData.name,
            description: controlData.description,
            policyTemplates: { connect: policyConnects },
            requirements: {
              connect: controlData.mappedRequirements.map(req => ({ 
                frameworkId_name: { frameworkId: req.frameworkId, name: req.requirementId }
              }))
            },
            taskTemplates: { connect: taskConnects }
          },
        });
      }
      console.log(`${allControlsData.length} FrameworkEditorControlTemplates created.`);
      console.log('Data reset transaction completed.');
    });

    revalidatePaths.forEach(path => revalidatePath(path));

    return { success: true, message: 'All data has been successfully reset to defaults.' };
  } catch (error) {

    revalidatePaths.forEach(path => revalidatePath(path));

    console.error('Error during data reset transaction:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred during data reset.';
    return { success: false, error: errorMessage };
  }
} 


